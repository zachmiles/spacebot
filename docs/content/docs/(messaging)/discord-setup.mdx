---
title: Discord Setup
description: Step-by-step guide to connect Spacebot to Discord.
---

# Discord Setup Guide

How to connect Spacebot to Discord so it can receive messages and respond through the Discord adapter.

## Quick Setup (Hosted)

If you're running a hosted instance on spacebot.sh, the embedded UI handles most of this for you:

1. Create a bot in the [Discord Developer Portal](#1-create-an-application) and copy the token
2. Open the **Agent Channels** tab in your instance UI
3. Click **Connect Channel** → select **Discord**
4. Paste your bot token and guild ID
5. Click **Add Binding** — the bot starts immediately, no restart needed

The rest of this guide covers manual `config.toml` setup and the full details.

## Discord Developer Portal

### 1. Create an Application

Go to https://discord.com/developers/applications and create a new application. Name it whatever you want — this is the internal name, not the bot's display name.

### 2. Create a Bot

Under the "Bot" section:

- Click "Add Bot"
- Copy the **bot token** — you'll need this for the config
- Under "Privileged Gateway Intents", enable:
  - **Message Content Intent** (required — without this, message bodies arrive empty)
  - **Server Members Intent** is NOT needed
  - **Presence Intent** is NOT needed

### 3. Generate an Invite URL

Under "OAuth2" > "URL Generator":

- Scopes: `bot`
- Bot Permissions:
  - Send Messages
  - Send Messages in Threads
  - Create Public Threads
  - Read Message History
  - Embed Links
  - Attach Files

Copy the generated URL and open it in your browser to invite the bot to your server.

### 4. Get Your Guild ID

In Discord, enable Developer Mode (User Settings > Advanced > Developer Mode). Right-click your server name and "Copy Server ID". This is your `guild_id`.

## Spacebot Configuration

Add the following to your `config.toml`:

```toml
[llm]
openrouter_key = "env:OPENROUTER_API_KEY"

[defaults.routing]
channel = "openrouter/anthropic/claude-sonnet-4-20250514"
worker = "openrouter/anthropic/claude-haiku-4.5-20250514"

[messaging.discord]
enabled = true
token = "env:DISCORD_BOT_TOKEN"

[[agents]]
id = "main"
default = true

# Route this Discord server to the "main" agent
[[bindings]]
agent_id = "main"
channel = "discord"
guild_id = "YOUR_GUILD_ID_HERE"
```

Set the environment variables:

```bash
export DISCORD_BOT_TOKEN="your-bot-token-here"
export OPENROUTER_API_KEY="your-openrouter-key-here"
```

### Discord Config Options

The full `[messaging.discord]` section:

```toml
[messaging.discord]
enabled = true
token = "env:DISCORD_BOT_TOKEN"
allow_bot_messages = false       # process messages from other bots (default: false)
dm_allowed_users = ["USER_ID"]   # user IDs allowed to DM the bot (instance-wide)
```

### Binding Options

Each `[[bindings]]` entry supports:

```toml
[[bindings]]
agent_id = "main"
channel = "discord"
guild_id = "123456789"
channel_ids = ["111111", "222222"]     # restrict to specific channels (empty = all)
dm_allowed_users = ["333333"]          # per-binding DM allowlist (merged with instance-wide)
```

- `channel_ids` — When set, the bot only responds in those channels (and threads parented to them). When empty, it responds in all channels.
- `dm_allowed_users` — User IDs allowed to DM the bot, scoped to this binding. Merged with the instance-wide `dm_allowed_users` on `[messaging.discord]`.

### LLM Providers

Spacebot supports three providers. Use whichever you prefer:

| Provider | Config key | Env var | Model prefix |
|----------|-----------|---------|-------------|
| OpenRouter | `openrouter_key` | `OPENROUTER_API_KEY` | `openrouter/` |
| Anthropic | `anthropic_key` | `ANTHROPIC_API_KEY` | `anthropic/` |
| OpenAI | `openai_key` | `OPENAI_API_KEY` | `openai/` |

OpenRouter is convenient because it gives you access to all models through a single API key. Model names use the format `openrouter/<provider>/<model>`:

```toml
[defaults.routing]
channel = "openrouter/anthropic/claude-sonnet-4-20250514"
worker = "openrouter/anthropic/claude-haiku-4.5-20250514"
cortex = "openrouter/anthropic/claude-haiku-4.5-20250514"
```

For direct API access without OpenRouter:

```toml
[llm]
anthropic_key = "env:ANTHROPIC_API_KEY"

[defaults.routing]
channel = "anthropic/claude-sonnet-4-20250514"
```

The `token` and key fields support `env:` prefix to read from environment variables at startup — credentials are never stored in plaintext in config.

### Multiple Servers

Route different Discord servers to different agents:

```toml
[[agents]]
id = "main"
default = true

[[agents]]
id = "dev-bot"
[agents.routing]
channel = "openrouter/anthropic/claude-sonnet-4-20250514"

[[bindings]]
agent_id = "main"
channel = "discord"
guild_id = "123456789"

[[bindings]]
agent_id = "dev-bot"
channel = "discord"
guild_id = "987654321"
```

Each agent has its own memory, identity, and conversation history. Messages from guild `123456789` go to the "main" agent, messages from `987654321` go to "dev-bot".

### Guild Filtering

When bindings specify guild IDs, the adapter only processes messages from those guilds. If no Discord bindings exist, the adapter accepts messages from all guilds the bot is in (routed to the default agent).

## How Messages Flow

```
User types in #general on Discord
    |
    v
Serenity gateway receives Message event
    |
    v
Handler.message() applies permission filters:
    - Ignore self (prevent loops)
    - Ignore other bots (unless allow_bot_messages)
    - DM: check dm_allowed_users
    - Guild: check guild_id against bindings
    - Channel: check channel_ids (if specified)
    |
    v
Builds InboundMessage:
    - id: Discord message snowflake
    - source: "discord"
    - conversation_id: "discord:GUILD_ID:CHANNEL_ID"
    - sender_id: Discord user ID
    - metadata: { discord_channel_id, discord_guild_id, ... }
    |
    v
mpsc channel -> InboundStream -> MessagingManager
    |
    v
Router resolves binding -> sets agent_id
    |
    v
Agent creates or reuses a Channel for this conversation_id
    |
    v
Channel processes the message (branch -> think -> reply)
    |
    v
ReplyTool -> OutboundResponse -> MessagingManager.respond()
    |
    v
DiscordAdapter.respond() -> Discord API -> User sees reply
```

### Conversation Mapping

Each Discord channel/thread maps to one Spacebot conversation:

| Discord Context | conversation_id | Spacebot Behavior |
|----------------|----------------|-------------------|
| Server channel `#general` | `discord:GUILD:CHANNEL` | One conversation per channel |
| Thread in `#general` | `discord:GUILD:THREAD` | One conversation per thread |
| DM with bot | `discord:dm:USER` | One conversation per DM (requires `dm_allowed_users`) |

Threads are the natural fit for isolated conversations. In a busy server channel, all messages in that channel share one conversation context. Threads give each interaction its own history.

### Typing Indicators

When the agent is thinking, Discord shows the "Spacebot is typing..." indicator. This auto-repeats until a response is sent. Typing stops when:
- The agent sends a response
- A non-Thinking status update arrives (tool execution, worker spawn, etc.)

### Message Length

Discord caps messages at 2000 characters. Long responses are automatically split at newlines (preferred), then spaces, then hard-cut at 2000 chars.

### Streaming

When streaming is enabled, the adapter sends an initial placeholder message on `StreamStart`, then edits it in-place as `StreamChunk` text accumulates. On `StreamEnd`, the placeholder is cleaned up. If accumulated text exceeds 2000 chars during streaming, it truncates with "..." (a future improvement would split into a new message).

## Hot Reload

Config changes take effect immediately — no restart required.

The Discord adapter watches `config.toml` for changes and hot-reloads permissions on every edit. This includes:
- Binding changes (guild IDs, channel IDs)
- DM allowlist changes
- `allow_bot_messages` toggle

Permissions are stored behind `ArcSwap`, so each incoming message loads a fresh snapshot. You can add a new binding, change channel filters, or update the DM allowlist and it takes effect on the next message.

Adding a binding via the embedded UI also hot-starts the Discord adapter if it wasn't already running — no restart needed.
