---
title: Roadmap
description: Development timeline and future plans for Spacebot.
---

# Roadmap

Tracking progress from first compile to public launch.

## Current State

The full message-in → LLM → response-out pipeline is wired end-to-end across Discord, Telegram, Slack, and webhooks. The system starts messaging adapters, routes inbound messages to agent channels via binding resolution, runs real Rig agent loops for channels/branches/workers, and routes outbound responses back through the messaging layer. The hosted platform (spacebot.sh) is deployed with a control plane, dashboard, and marketing site. Config changes hot-reload without restarts.

## Completed

- **Project structure** — all modules declared, module root pattern (`src/memory.rs` not `mod.rs`)
- **Error hierarchy** — thiserror domain enums wrapped by top-level `Error` with `#[from]`
- **Config** — hierarchical TOML with `Config`, `AgentConfig`, `ResolvedAgentConfig`, `Binding`, `MessagingConfig`. File watcher with event filtering and content hash debounce for hot-reload.
- **Multi-agent** — per-agent database isolation, `Agent` struct bundles all dependencies
- **Database connections** — SQLite + LanceDB + redb per-agent, migrations for all tables
- **LLM** — `SpacebotModel` implements Rig's `CompletionModel`, routes through `LlmManager` via HTTP with retries and fallback chains across 4 providers (Anthropic, OpenAI, OpenRouter, Zhipu)
- **Model routing** — `RoutingConfig` with process-type defaults, task overrides, fallback chains
- **Memory** — full stack: types, SQLite store (CRUD + graph), LanceDB (embeddings + vector + FTS), fastembed, hybrid search (RRF fusion). `memory_type` filter wired end-to-end through SearchConfig. `total_cmp` for safe sorting.
- **Memory maintenance** — decay + prune implemented
- **Identity** — `Identity` struct loads SOUL.md/IDENTITY.md/USER.md, `Prompts` with fallback chain
- **Agent loops** — all three process types run real Rig loops:
  - **Channel** — per-turn tool registration, status injection, `max_turns(5)`
  - **Branch** — history fork, `max_turns(10)`, memory tools, result injection
  - **Worker** — fresh history, per-worker ToolServer, `max_turns(50)`, interactive mode with `input_tx` stored in ChannelState
- **Compactor** — tiered thresholds (80%/85%/95%), LLM summarization, pre-compaction archiving, emergency truncation
- **Cortex** — signal buffering, bulletin generation on 60min interval, association loop
- **StatusBlock** — event-driven updates, renders to context string
- **Hooks** — `SpacebotHook` with tool call/result events, leak detection (11 patterns scanning both tool args and output); `CortexHook` for observation (trace-only)
- **Messaging** — `Messaging` trait with RPITIT + companion, `MessagingManager` with fan-in/routing
- **Discord adapter** — full Serenity implementation (message handling, streaming via edit, typing indicators, guild/channel/DM filtering)
- **Telegram adapter** — full teloxide implementation (long polling, typing indicators, attachment extraction, chat/DM filtering, 4096 char splitting)
- **Slack adapter** — full slack-morphism implementation (Socket Mode, thread replies, file upload v2, reactions, streaming via edit, workspace/channel/DM filtering via hot-reloadable permissions)
- **Webhook adapter** — Axum HTTP server (POST /send, GET /poll/{id}, GET /health)
- **Tools** — 16 tools implement Rig's `Tool` trait with real logic (reply, branch, spawn_worker, route, cancel, skip, react, memory_save, memory_recall, set_status, shell, file, exec, browser, cron, web_search)
- **Workspace containment** — file tool validates paths stay within workspace boundary, shell/exec tools block instance directory traversal, sensitive file access, and secret env var leakage
- **Conversation persistence** — `ConversationLogger` with fire-and-forget SQLite writes, compaction archiving
- **Cron** — scheduler with timers, active hours, circuit breaker (3 failures → disable), creates real channels. CronTool wired into channel tool factory.
- **Message routing** — full event loop with binding resolution, channel lifecycle, outbound routing
- **Settings store** — redb key-value with WorkerLogMode
- **OpenClaw skills** — skill format parsing, tool mapping, directory watcher with hot reload, instance + per-agent directories
- **Embedded UI** — Vite + React + TypeScript SPA, embedded into binary via rust_embed, served as SPA fallback
- **Bindings API** — hot-creates bindings and starts adapters at runtime without restart via ArcSwap
- **Hosted platform** — control plane (spacebot-platform on Fly.io), dashboard (spacebot-dash), marketing site (spacebot-web). Instance provisioning, auth, reverse proxy to private Fly VMs.

## In Progress

- **Cortex consolidation** — `run_consolidation()` is a stub, no actual memory merging or graph optimization
- **Memory merge** — `merge_similar_memories()` is a no-op placeholder
- **Cortex observe()** — extracts some event types but hardcodes `memory_type` and `importance` values instead of pulling from actual event data
- **CortexHook** — all hook methods are trace-only passthrough, no observation logic
- **Secrets store** — empty struct, no redb/AES-256-GCM integration

## Upcoming

### Streaming

Implement `SpacebotModel.stream()` with SSE parsing. The messaging adapters already handle `StreamStart`/`StreamChunk`/`StreamEnd` response types — this is purely the LLM layer.

### Cortex Consolidation

- Implement `run_consolidation()` — memory merging, decay management, graph optimization
- Implement `merge_similar_memories()` in maintenance.rs
- Cross-channel coherence — shared observations across an agent's conversations
- Wire real values into `observe()` signal extraction
- Implement CortexHook observation logic (anomaly detection, consolidation triggers)

### Secrets Store

AES-256-GCM encrypted credentials in redb with `DecryptedSecret` wrapper type.

### Hardening

- Tool nudging — inject "use your tools" in `SpacebotHook.on_completion_response()` when LLM responds with text in early iterations
- Outbound HTTP leak scanning — block exfiltration via tool output before it reaches external services

### Ingestion Pipeline

Drop files in, agent picks them up.

- File watcher on `agents/{id}/ingest/` directory
- Chunking — split large files into context-window-safe segments
- Per-chunk worker using INGESTION.md prompt — recall existing, extract memories, build associations
- Cleanup — move processed files to `agents/{id}/ingest/done/`

## Post-Launch

- **Agent CLI** — `spacebot agents list/create/delete`, identity template bootstrapping
- **Cross-agent communication** — routing between agents, shared observations
- **Hot reload agent topology** — adding/removing agents without restart
- **Agent templates** — pre-built configurations for common use cases
- **JsonSchema-derived tool definitions** — replace hand-written JSON schemas in all tools with the `JsonSchema` derive that's already on every Args struct
- **Spacedrive integration** — connect agents to terabytes of indexed, content-addressed file data across devices
